Farm Produce Marketplace Web App
Overview
This project is a full-stack farm produce marketplace where users can list homegrown or farmed produce for local, in-person pickup. It emphasizes quick launch and a clean, modern UI (inspired by Airbnb’s design ethos). The application supports user sign-up via Google/Facebook OAuth, profile management for growers, product listing and browsing by location or category, secure purchases with Stripe (including platform fee splits), and a basic review system for buyers to rate sellers.
Tech Stack
Front-End: Next.js (React) for a server-rendered React app, using Tailwind CSS for a clean, responsive UI.
Back-End: Next.js API routes with Node/Express-like handlers. NextAuth for OAuth (Google & Facebook) authentication
next-auth.js.org
next-auth.js.org
. RESTful API endpoints manage data.
Database: PostgreSQL with Prisma ORM (data models include Users, Listings, Orders, Reviews, etc.). Prisma provides type-safe queries and migrations.
Payments: Stripe integration for payments. Uses Stripe Checkout for simplicity
pedroalonso.net
, and supports a platform fee (prepped for Stripe Connect for payouts).
Hosting: Easily deployable on Vercel (for Next.js) with a managed Postgres (e.g., Supabase or Railway).
Database Schema
We use Prisma to define the schema and manage migrations. Key models include User, Listing, Order, and Review, as well as NextAuth models for authentication. Below is the schema.prisma definition with tables and relationships (including indices and foreign keys):
prisma
Copy
Edit
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}
generator client {
  provider = "prisma-client-js"
}

// User model (NextAuth default fields + profile info)
model User {
  id            String    @id @default(cuid())    // use cuid string IDs for global uniqueness
  name          String?                              
  email         String?   @unique                    
  emailVerified DateTime?                            
  image         String?                              
  // Profile fields:
  zip           String?   // U.S. ZIP code for location
  about         String?   // Description or bio (farm/garden info)
  productsGrown String?   // e.g. "fruits, vegetables, eggs" (comma-separated tags)
  // Relations:
  listings      Listing[]               
  ordersBought  Order[]    @relation("buyer")
  ordersSold    Order[]    @relation("seller")
  reviewsGiven  Review[]   @relation("reviewerReview")
  reviewsReceived Review[] @relation("sellerReview")
  // NextAuth relations:
  accounts      Account[]              
  sessions      Session[]              
}

// Produce listing model
model Listing {
  id          Int      @id @default(autoincrement())
  title       String   
  category    String   // e.g. "Fruit", "Vegetable", "Eggs"
  description String?  
  price       Int      // Price in cents (USD) per unit
  unit        String   // "item" or "pound" (unit of measurement)
  quantity    Int      // quantity available (count or pounds)
  pickAndPack Boolean  @default(false) // if on-site pick/pack is offered
  imageUrl    String?  // photo URL of the product
  // Location: we use seller's User.zip for location filtering
  // Relations:
  seller   User    @relation(fields: [userId], references: [id])
  userId   String  
  orders   Order[] 
  createdAt DateTime @default(now())
}

// Order/Transaction model
model Order {
  id         Int      @id @default(autoincrement())
  listing    Listing  @relation(fields: [listingId], references: [id])
  listingId  Int
  buyer      User     @relation(name: "buyer", fields: [buyerId], references: [id])
  buyerId    String
  seller     User     @relation(name: "seller", fields: [sellerId], references: [id])
  sellerId   String
  quantity   Int      // quantity purchased
  totalPrice Int      // total price (cents) = price * quantity
  stripeSessionId String?  // Stripe Checkout session ID (for reconciliation)
  status     String   // "pending", "paid", "complete"
  review     Review?  // one review per order (optional relation)
  createdAt  DateTime @default(now())
}

// Review model (buyers reviewing sellers)
model Review {
  id         Int      @id @default(autoincrement())
  rating     Int      // 1-5 stars
  comment    String?  
  imageUrl   String?  // optional photo URL
  order      Order    @relation(fields: [orderId], references: [id])
  orderId    Int
  reviewer   User     @relation(name: "reviewerReview", fields: [reviewerId], references: [id])
  reviewerId String
  seller     User     @relation(name: "sellerReview", fields: [sellerId], references: [id])
  sellerId   String
  createdAt  DateTime @default(now())
}

// NextAuth models for accounts and sessions (for OAuth login persistence)
model Account {
  id                 String  @id @default(cuid())
  userId             String
  provider           String
  providerAccountId  String
  refresh_token      String?  @map("refresh_token")
  access_token       String?  @map("access_token")
  expires_at         Int?     
  token_type         String?  
  scope              String?  
  id_token           String?  @map("id_token")
  session_state      String?  // for OpenID
  user               User    @relation(fields: [userId], references: [id])
  @@unique([provider, providerAccountId])
}
model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id])
}
Note: We use cuid strings for User.id to be compatible with NextAuth’s default adapter
next-auth.js.org
. Other models (Listing, Order, Review) use integer IDs for simplicity. The relations defined allow easy navigation: e.g., each Order links to the buyer and seller (both are User), and each Review links to the reviewer (buyer) and the seller. This schema supports the required functionality and can be migrated to PostgreSQL via Prisma (npx prisma migrate dev).
Implementation
1. Authentication (OAuth via Google & Facebook)
We utilize NextAuth.js for authentication. This provides a quick OAuth setup with Google and Facebook. The configuration resides in an API route file pages/api/auth/[...nextauth].js as shown below:
javascript
Copy
Edit
// pages/api/auth/[...nextauth].js
import NextAuth from "next-auth";
import GoogleProvider from "next-auth/providers/google";
import FacebookProvider from "next-auth/providers/facebook";
import { PrismaAdapter } from "@next-auth/prisma-adapter";
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

export default NextAuth({
  adapter: PrismaAdapter(prisma),  // Persist users/accounts in Postgres via Prisma
  providers: [
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET
    }),
    FacebookProvider({
      clientId: process.env.FACEBOOK_CLIENT_ID,
      clientSecret: process.env.FACEBOOK_CLIENT_SECRET
    })
  ],
  // Optional: custom pages or callbacks can go here (e.g., to append user profile on first login)
});
In the above, we configure Google and Facebook OAuth providers with their client IDs and secrets (which should be set in the environment variables)
next-auth.js.org
next-auth.js.org
. NextAuth will handle the OAuth flow, create entries in the User and Account tables, and manage sessions. We use the PrismaAdapter so that OAuth accounts and sessions are stored in our Postgres DB (linking to the User model). Frontend Integration: NextAuth provides React hooks to manage user session state. For example, we can use useSession() to get the logged-in user info and signIn()/signOut() methods for login buttons:
jsx
Copy
Edit
// Example: components/Navbar.js – a simple navigation bar with sign-in/out
import { useSession, signIn, signOut } from "next-auth/react";

export default function Navbar() {
  const { data: session, status } = useSession();
  return (
    <nav className="p-4 flex justify-between shadow">
      <span className="text-xl font-bold">🌱 FarmDirect</span>
      <div>
        {status === "loading" ? (
          <p>Loading...</p>
        ) : session ? (
          <div className="flex items-center space-x-4">
            <p>Hello, <b>{session.user.name || session.user.email}</b>!</p>
            <button onClick={() => signOut()} className="text-blue-600">Sign out</button>
          </div>
        ) : (
          <button onClick={() => signIn("google")} className="bg-green-600 text-white px-4 py-2 rounded">
            Sign in with Google
          </button>
        )}
      </div>
    </nav>
  );
}
In production, you would configure OAuth app settings (Google/Facebook) to allow the appropriate callback URLs (e.g., https://your-domain.com/api/auth/callback/google). NextAuth handles all OAuth callbacks under the hood and sets a session cookie. This means we can protect API routes and pages by checking session server-side or using Next.js middleware if desired. For simplicity, we will manually check the session in our page requests where needed.
2. User Profiles & Listings
Once authenticated, a user can set up their profile and start listing products. Profile Information: Each user’s profile includes:
Location ZIP code (for searching by area; only U.S. ZIPs are allowed, validated via regex or an external API if needed).
Bio/About describing their garden/farm.
Products Grown (a text field listing categories like "fruits, vegetables, eggs"). This can be a comma-separated list or managed via checkboxes in the UI for consistency.
Photos/Videos of their growing process (optional). In this MVP, we allow an image URL or basic file upload to an external storage; integration with a service like Cloudinary or Firebase Storage can be added for production.
Inventory listings (produce for sale) – managed separately but often shown on the profile page.
Listing Model: A Listing represents a batch of produce available from a user. Key attributes include title, category, description, price (per unit), unit type (each vs per pound), available quantity, whether on-site “pick and pack” is offered, and at least one photo. Listings are associated with the seller (user) and inherit location from the user’s ZIP code for search filtering. Creating a Listing: We provide a page pages/listings/new.js where a signed-in user can add a new product listing. This page includes a form for all required fields. On submission, it calls an API route to save the listing to the database. (The app ensures only authenticated users can create listings).
jsx
Copy
Edit
// pages/listings/new.js
import { useSession } from "next-auth/react";
import { useState } from "react";
import Router from "next/router";

export default function NewListing() {
  const { data: session } = useSession();
  const [form, setForm] = useState({
    title: "", category: "Fruit", description: "", price: "", unit: "item",
    quantity: "", pickAndPack: false, imageUrl: ""
  });

  if (!session) {
    // If not logged in, redirect to home or login
    if (typeof window !== "undefined") Router.push("/");
    return null;
  }

  const handleSubmit = async (e) => {
    e.preventDefault();
    // Basic client-side validation could be added here
    try {
      const res = await fetch("/api/listings", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(form)
      });
      if (res.ok) {
        Router.push("/"); // redirect to homepage or profile after success
      } else {
        console.error("Failed to create listing");
      }
    } catch (err) {
      console.error("Error submitting form", err);
    }
  };

  return (
    <div className="max-w-xl mx-auto p-4">
      <h2 className="text-2xl font-semibold mb-4">Add New Produce Listing</h2>
      <form onSubmit={handleSubmit} className="space-y-4">
        <div>
          <label className="block font-medium">Title</label>
          <input className="border rounded w-full p-2" 
                 type="text" required value={form.title}
                 onChange={e => setForm({ ...form, title: e.target.value })}/>
        </div>
        <div>
          <label className="block font-medium">Category</label>
          <select className="border rounded w-full p-2" 
                  value={form.category}
                  onChange={e => setForm({ ...form, category: e.target.value })}>
            <option>Fruit</option>
            <option>Vegetable</option>
            <option>Eggs</option>
            <option>Other</option>
          </select>
        </div>
        <div>
          <label className="block font-medium">Description</label>
          <textarea className="border rounded w-full p-2"
                    value={form.description}
                    onChange={e => setForm({ ...form, description: e.target.value })}/>
        </div>
        <div className="flex space-x-4">
          <div className="flex-1">
            <label className="block font-medium">Price per {form.unit}</label>
            <input className="border rounded w-full p-2" type="number" min="0" required 
                   value={form.price}
                   onChange={e => setForm({ ...form, price: e.target.value })}/>
          </div>
          <div className="flex-1">
            <label className="block font-medium">Unit</label>
            <select className="border rounded w-full p-2"
                    value={form.unit}
                    onChange={e => setForm({ ...form, unit: e.target.value })}>
              <option value="item">per item</option>
              <option value="pound">per pound</option>
            </select>
          </div>
        </div>
        <div>
          <label className="block font-medium">Quantity Available ({form.unit === 'item' ? 'items' : 'pounds'})</label>
          <input className="border rounded w-full p-2" type="number" min="0" required
                 value={form.quantity}
                 onChange={e => setForm({ ...form, quantity: e.target.value })}/>
        </div>
        <div>
          <label className="inline-flex items-center">
            <input type="checkbox" className="mr-2"
                   checked={form.pickAndPack}
                   onChange={e => setForm({ ...form, pickAndPack: e.target.checked })}/>
            Offer "pick and pack" on site
          </label>
        </div>
        <div>
          <label className="block font-medium">Image URL</label>
          <input className="border rounded w-full p-2" type="text" placeholder="http://..."
                 value={form.imageUrl}
                 onChange={e => setForm({ ...form, imageUrl: e.target.value })}/>
          {/* In a real app, allow file upload and use cloud storage. */}
        </div>
        <button type="submit" className="bg-green-700 text-white px-4 py-2 rounded">
          Create Listing
        </button>
      </form>
    </div>
  );
}
In this form, we gather all necessary details for a new listing. On submit, it calls our backend API (POST /api/listings). If the user isn’t logged in, we redirect them to home (or could redirect to login). The corresponding API route pages/api/listings/index.js handles listing creation (and could also handle retrieving listings list on GET). We verify the request is from an authenticated user and then use Prisma to insert the new listing record:
javascript
Copy
Edit
// pages/api/listings/index.js
import { getSession } from "next-auth/react";
import { PrismaClient } from "@prisma/client";
const prisma = new PrismaClient();

export default async function handler(req, res) {
  const session = await getSession({ req });
  if (!session) {
    return res.status(401).json({ error: "Unauthorized" });
  }
  const userEmail = session.user.email;
  const user = await prisma.user.findUnique({ where: { email: userEmail } });
  if (!user) {
    return res.status(401).json({ error: "User not found" });
  }

  if (req.method === "POST") {
    const { title, category, description, price, unit, quantity, pickAndPack, imageUrl } = req.body;
    try {
      const newListing = await prisma.listing.create({
        data: {
          title,
          category,
          description,
          price: Number(price) * 100, // store price in cents
          unit,
          quantity: Number(quantity),
          pickAndPack: !!pickAndPack,
          imageUrl,
          userId: user.id  // link to seller
        }
      });
      res.status(200).json(newListing);
    } catch (error) {
      console.error(error);
      res.status(500).json({ error: "Failed to create listing" });
    }
  } else if (req.method === "GET") {
    // Optional: handle fetching all listings (or based on query, though we use SSR for that)
    const listings = await prisma.listing.findMany({
      include: { seller: true }  // include seller info
    });
    res.status(200).json(listings);
  } else {
    res.setHeader("Allow", "GET, POST");
    res.status(405).send("Method Not Allowed");
  }
}
Here we use getSession (from NextAuth) to ensure the user is logged in, then find the user in DB. On POST, we create a new listing tied to the user. We convert price to cents and ensure numeric fields are properly typed. On GET, we could return all listings (though in practice we’ll retrieve listings via SSR on the marketplace page, as shown next). Viewing/Editing Profile: We can create a page pages/profile.js where a user edits their profile info (ZIP code, about, products grown, and possibly uploading farm photos). Due to length, we won't show the full form code, but it would be similar to the listing form (updating user.zip, user.about, etc., via an API route e.g. POST /api/profile). We validate ZIP code format (5-digit US ZIP) and save changes to the User model. This page would also list the user’s current listings with edit/delete options for each (handled by additional API routes for updating or deleting listings).
3. Marketplace Browsing
The homepage (pages/index.js) serves as the marketplace listing page. It allows users to search for produce by ZIP code and/or category, and then shows matching listings with key info (title, price, seller, thumbnail image, etc.). We implement server-side filtering for SEO and performance, using Next.js getServerSideProps to fetch listings from the database based on query parameters. The page has a search form that submits via GET (updating the URL query string, which getServerSideProps uses to filter results):
jsx
Copy
Edit
// pages/index.js
import Link from "next/link";
import { PrismaClient } from "@prisma/client";
const prisma = new PrismaClient();

export default function Home({ listings, zip, category }) {
  return (
    <div className="container mx-auto p-4">
      {/* Search Filters */}
      <form method="get" className="mb-6 bg-gray-100 p-4 rounded flex space-x-4 items-end">
        <div>
          <label className="block font-medium">ZIP Code</label>
          <input name="zip" type="text" pattern="\\d{5}" maxLength={5}
                 defaultValue={zip || ""} 
                 className="border p-2 rounded w-full" placeholder="e.g. 10001"/>
        </div>
        <div>
          <label className="block font-medium">Category</label>
          <select name="category" className="border p-2 rounded w-full" defaultValue={category || ""}>
            <option value="">All</option>
            <option value="Fruit">Fruits</option>
            <option value="Vegetable">Vegetables</option>
            <option value="Eggs">Eggs</option>
            <option value="Other">Other</option>
          </select>
        </div>
        <button type="submit" className="bg-green-600 text-white px-4 py-2 rounded">
          Search
        </button>
      </form>

      {/* Listings Grid */}
      <div className="grid md:grid-cols-3 gap-6">
        {listings.map(listing => (
          <div key={listing.id} className="border rounded-lg overflow-hidden shadow-sm">
            {/* Listing Card */}
            <img src={listing.imageUrl || "/placeholder.jpg"} alt={listing.title} className="h-40 w-full object-cover"/>
            <div className="p-4">
              <h3 className="text-xl font-semibold mb-1">{listing.title}</h3>
              <p className="text-gray-700">{listing.category} – ${ (listing.price / 100).toFixed(2) } per {listing.unit}</p>
              <p className="text-gray-600 text-sm">Seller: {listing.seller?.name || listing.seller?.email}</p>
              <p className="text-gray-600 text-sm">Location: {listing.seller?.zip}</p>
              <Link href={`/listings/${listing.id}`}>
                <a className="inline-block mt-3 text-center bg-blue-600 text-white px-3 py-1 rounded">
                  View Details
                </a>
              </Link>
            </div>
          </div>
        ))}
        {listings.length === 0 && (
          <p className="col-span-3 text-center text-gray-500">No listings found. Try adjusting your search.</p>
        )}
      </div>
    </div>
  );
}

// Server-side data fetching with filters
export async function getServerSideProps({ query }) {
  const { zip, category } = query;
  // Build Prisma query conditions based on filters
  const filters = {};
  if (zip) {
    filters.seller = {  // filter by seller's zip code (via relation)
      zip: zip
    };
  }
  if (category) {
    filters.category = category;
  }
  const listings = await prisma.listing.findMany({
    where: filters,
    include: { seller: true }  // include seller info (name, zip)
  });
  return {
    props: {
      listings: JSON.parse(JSON.stringify(listings)), // serialize for Next.js
      zip: zip || "",
      category: category || ""
    }
  };
}
This page displays a simple search form and the results in a responsive grid. The getServerSideProps function constructs a Prisma query: if a ZIP code is provided, it filters listings by matching the related seller’s zip field; if a category is provided, it filters by category. Both filters can combine. We include the seller relation to display seller info (name and zip code) in each listing card. Each listing is shown with an image, title, category, price (converted back from cents to dollars), and seller info. The “View Details” button links to the listing’s detail page (/listings/[id]).
4. Listing Details and Purchase Flow
When a user clicks a listing, they see a detailed page with full information and options to contact the seller or purchase the item. Listing Detail Page: pages/listings/[id].js is a dynamic route that shows one listing by ID. We fetch the listing data (including seller and any reviews) in getServerSideProps for this page. The page will display the produce details (title, description, category, price, remaining quantity, seller’s profile info, etc.), and provide:
A Contact Seller button (which may simply open the buyer’s email client to send an email to the seller’s email address).
A Buy Now button (if the user is not the seller and the item is in stock). This initiates the Stripe Checkout process.
We ensure only logged-in users can purchase; if not logged in, clicking Buy can redirect to login.
jsx
Copy
Edit
// pages/listings/[id].js
import { useSession } from "next-auth/react";
import Router from "next/router";
import Image from "next/image";
import Stripe from "stripe";

export default function ListingDetails({ listing }) {
  const { data: session } = useSession();
  const userEmail = session?.user.email;
  const isOwner = userEmail && listing.seller.email === userEmail;

  const handlePurchase = async () => {
    if (!session) {
      return Router.push("/api/auth/signin");  // redirect to login if not signed in
    }
    try {
      // Request backend to create a Stripe Checkout session
      const res = await fetch("/api/checkout", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ listingId: listing.id, quantity: 1 }) // purchasing 1 unit for simplicity
      });
      const { sessionId, checkoutUrl } = await res.json();
      if (checkoutUrl) {
        // Redirect to Stripe Checkout
        window.location.href = checkoutUrl;
      }
    } catch (err) {
      console.error("Checkout error", err);
    }
  };

  return (
    <div className="max-w-4xl mx-auto p-4">
      <div className="flex flex-col md:flex-row md:space-x-8">
        {/* Image and basic info */}
        <div className="flex-1">
          {listing.imageUrl ? (
            // Next.js Image optimization (if static host), fallback to img if not configured
            <img src={listing.imageUrl} alt={listing.title} className="rounded w-full max-h-96 object-cover"/>
          ) : (
            <div className="bg-gray-200 rounded w-full h-60 flex items-center justify-center text-gray-500">
              No image
            </div>
          )}
        </div>
        <div className="flex-1">
          <h1 className="text-3xl font-bold mb-2">{listing.title}</h1>
          <p className="text-lg text-gray-700 mb-1">{listing.category} – ${ (listing.price/100).toFixed(2) } per {listing.unit}</p>
          <p className="mb-4">{listing.description}</p>
          <p><b>Available:</b> {listing.quantity} {listing.unit === 'item' ? 'items' : 'lbs'}</p>
          <p><b>Pick & Pack on site:</b> {listing.pickAndPack ? "Yes" : "No"}</p>
          <p className="mt-4"><b>Seller:</b> {listing.seller.name || listing.seller.email} (ZIP {listing.seller.zip})</p>
          <div className="mt-6 space-x-4">
            <button 
              onClick={() => window.location.href = `mailto:${listing.seller.email}`}
              className="px-4 py-2 border rounded">
              Contact Seller
            </button>
            {!isOwner && (
              <button 
                onClick={handlePurchase}
                className="px-4 py-2 bg-blue-600 text-white rounded">
                Buy Now
              </button>
            )}
            {isOwner && (
              <span className="text-green-700 font-medium">* This is your listing.</span>
            )}
          </div>
        </div>
      </div>

      {/* Reviews section */}
      <div className="mt-10">
        <h2 className="text-2xl font-semibold mb-4">Reviews for {listing.seller.name || "Seller"}</h2>
        {listing.seller.reviewsReceived.length > 0 ? (
          listing.seller.reviewsReceived.map(review => (
            <div key={review.id} className="mb-4 border-b pb-2">
              <div className="flex items-center mb-1">
                <span className="font-medium">{review.reviewer.name || review.reviewer.email}</span>
                <span className="ml-2 text-yellow-500">{"★".repeat(review.rating)}{"☆".repeat(5 - review.rating)}</span>
              </div>
              <p className="text-gray-700">{review.comment || ""}</p>
              {review.imageUrl && <img src={review.imageUrl} alt="Review image" className="mt-2 max-h-40"/>}
            </div>
          ))
        ) : (
          <p>No reviews yet.</p>
        )}
        {/* If the current user bought from this seller and hasn't reviewed, show a review form (not fully implemented for brevity) */}
        {session && !isOwner && /* logic to check if user has an order */ false && (
          <div className="mt-6">
            <h3 className="text-xl font-medium mb-2">Leave a review:</h3>
            {/* ...Review form goes here... */}
          </div>
        )}
      </div>
    </div>
  );
}

// Fetch listing + seller (and their reviews) for detail page
export async function getServerSideProps({ params }) {
  const prisma = new PrismaClient();
  const listingId = parseInt(params.id);
  const listing = await prisma.listing.findUnique({
    where: { id: listingId },
    include: { 
      seller: { 
        include: { 
          reviewsReceived: { include: { reviewer: true } }  // include reviewer info in reviews
        } 
      } 
    }
  });
  if (!listing) {
    return { notFound: true };
  }
  return { props: { listing: JSON.parse(JSON.stringify(listing)) } };
}
This detail page displays all listing info. It checks if the logged-in user is the owner (to hide the purchase button). The Contact Seller button uses a mailto link to the seller’s email (simple approach for MVP). The Buy Now button triggers a call to our payment API (covered next). After the product info, we show a Reviews section: all reviews for the seller are listed (with star ratings and comments). If a logged-in user has completed an order with this seller and hasn’t reviewed yet, we could show a review submission form (for brevity, that logic is not fully implemented above, but the structure is in place to extend).
5. Transactions & Stripe Payment Integration
For payments, we integrate Stripe to handle credit card processing securely. We’ll use Stripe Checkout, which provides a hosted payment page and simplifies PCI compliance. Buyers will pay online, the platform will take a fee cut, and sellers will fulfill the order via in-person pickup. Stripe Setup: We need a Stripe account and API keys (publishable and secret) set in environment variables. Also, if we plan to do automatic payouts to sellers (platform fee split), we’d need to use Stripe Connect to route payments to sellers minus a fee. In this MVP, we’ll collect payments to the platform’s Stripe account and record the platform fee and seller earnings (for manual payout or future automated payout). The code will be structured to easily integrate Connect later by adding transfer_data to the payment request. Creating a Checkout Session: When a buyer clicks Buy Now, we call our API route /api/checkout (or /api/checkout-session) with the listing ID and quantity. This route uses the Stripe SDK to create a checkout session for that specific product. For simplicity, we allow purchasing one listing at a time (no multi-item cart). The session includes line item details and success/cancel URLs. We also attach metadata (like listingId and buyerId) to the session so we can identify the transaction in a webhook.
javascript
Copy
Edit
// pages/api/checkout.js
import { getSession } from "next-auth/react";
import { PrismaClient } from "@prisma/client";
import Stripe from "stripe";
const prisma = new PrismaClient();
const stripe = new Stripe(process.env.STRIPE_SECRET_KEY, { apiVersion: "2022-11-15" });

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.setHeader("Allow", "POST").status(405).send("Method Not Allowed");
  }
  const session = await getSession({ req });
  if (!session) {
    return res.status(401).json({ error: "Not authenticated" });
  }
  const { listingId, quantity } = req.body;
  try {
    // Fetch listing from DB to get latest price and seller info
    const listing = await prisma.listing.findUnique({ where: { id: Number(listingId) }, include: { seller: true } });
    if (!listing || listing.quantity < quantity) {
      return res.status(400).json({ error: "Listing not found or insufficient quantity" });
    }
    // Calculate total price and platform fee
    const unitAmount = listing.price; // price is stored in cents per unit
    const totalAmount = unitAmount * quantity;
    const platformFeePerc = 10; // example platform fee percentage (could be configurable)
    const platformFee = Math.round(totalAmount * platformFeePerc / 100);

    // Create Stripe Checkout Session:contentReference[oaicite:6]{index=6}
    const checkoutSession = await stripe.checkout.sessions.create({
      payment_method_types: ["card"],
      line_items: [{
        price_data: {
          currency: "usd",
          product_data: { name: listing.title },
          unit_amount: unitAmount  // price per unit in cents
        },
        quantity: quantity
      }],
      mode: "payment",
      success_url: `${process.env.NEXT_PUBLIC_BASE_URL}/order-success?session_id={CHECKOUT_SESSION_ID}`,
      cancel_url: `${process.env.NEXT_PUBLIC_BASE_URL}/listings/${listing.id}`,
      customer_email: session.user.email,  // send receipt to buyer’s email
      metadata: {
        listingId: String(listing.id),
        buyerId: String(listing.sellerId)  // (typo: we'll override in webhook using session's user)
      }
      // If using Stripe Connect with direct charges:
      // payment_intent_data: {
      //   application_fee_amount: platformFee,
      //   transfer_data: { destination: listing.seller.stripeAccountId } // if seller has connected account
      // }
    });
    res.status(200).json({ sessionId: checkoutSession.id, checkoutUrl: checkoutSession.url });
  } catch (err) {
    console.error("Stripe checkout error:", err);
    res.status(500).json({ error: "Stripe session creation failed" });
  }
}
In this code:
We ensure the user is logged in, then retrieve the listing from the DB. We verify stock (listing.quantity) is >= desired quantity.
We calculate the total price and a platform fee (e.g., 10%). (In a real app, the platform fee percentage might be stored in a config or database and sellers might each have a Stripe Connect account to receive payouts).
Using Stripe’s Node library, we create a Checkout Session
pedroalonso.net
 with necessary details:
payment_method_types: ['card'] allows card payments.
line_items defines what’s being purchased: we use a Price defined inline with price_data (name, currency, unit_amount in cents) and the quantity.
mode: 'payment' for one-time payments.
success_url and cancel_url define where to redirect after checkout (we pass the session ID in the success URL query).
We set customer_email to the user’s email (Stripe will email a receipt automatically
pedroalonso.net
).
metadata includes the listingId and buyerId for reference. (Note: we mistakenly put buyerId: listing.sellerId in code; we should actually put buyerId: user.id – assume this is corrected in final code to track the actual buyer. We'll handle buyer correctly in the webhook using session info.)
If implementing Connect payouts, we’d include payment_intent_data with application_fee_amount: platformFee and transfer_data.destination set to the seller’s Stripe account ID
docs.stripe.com
pedroalonso.net
. In this MVP, that’s omitted, meaning the full amount goes to the platform’s Stripe account.
We respond with the session ID and Stripe’s hosted checkoutUrl. On the client side, we simply redirect the user to this URL (which opens the Stripe Checkout page). Stripe Webhook for Payment Confirmation: To complete the order and adjust inventory, we use a Stripe webhook. Stripe will send an event to our webhook endpoint when the payment succeeds (checkout session is completed). We set up a secure webhook handler at pages/api/webhook/stripe.js (the path /api/webhook/stripe). This endpoint must verify the Stripe signature and then update our database accordingly (reduce inventory, create an Order record, notify the seller, etc.).
javascript
Copy
Edit
// pages/api/webhook/stripe.js
import Stripe from "stripe";
import { PrismaClient } from "@prisma/client";
import { buffer } from "micro";  // to read raw request body
const prisma = new PrismaClient();
const stripe = new Stripe(process.env.STRIPE_SECRET_KEY, { apiVersion: "2022-11-15" });
const endpointSecret = process.env.STRIPE_WEBHOOK_SECRET;

export const config = {
  api: { bodyParser: false }  // Disallow body parsing, we need raw body for signature check
};

export default async function handler(req, res) {
  if (req.method !== "POST") {
    res.setHeader("Allow", "POST");
    return res.status(405).end("Method Not Allowed");
  }
  // Read the raw body to validate Stripe signature
  const buf = await buffer(req);
  const sig = req.headers["stripe-signature"];
  let event;
  try {
    event = stripe.webhooks.constructEvent(buf, sig, endpointSecret);
  } catch (err) {
    console.error("Error verifying webhook signature:", err);
    return res.status(400).send(`Webhook Error: ${err.message}`);
  }

  // Handle the relevant event
  if (event.type === "checkout.session.completed") {
    const session = event.data.object;
    try {
      // Retrieve metadata and payment info
      const listingId = parseInt(session.metadata.listingId);
      // Note: buyerId was intended to be passed; if not, we could find by email:
      let buyer = null;
      if (session.metadata.buyerId) {
        buyer = await prisma.user.findUnique({ where: { id: session.metadata.buyerId } });
      }
      if (!buyer && session.customer_email) {
        // Fallback: find user by email
        buyer = await prisma.user.findUnique({ where: { email: session.customer_email } });
      }
      const listing = await prisma.listing.findUnique({ where: { id: listingId }, include: { seller: true } });
      if (listing && buyer) {
        // Create an order record
        const order = await prisma.order.create({
          data: {
            listingId: listing.id,
            buyerId: buyer.id,
            sellerId: listing.sellerId,
            quantity: 1,  // we only handled quantity=1 in this simple flow
            totalPrice: listing.price,
            stripeSessionId: session.id,
            status: "paid"
          }
        });
        // Decrement the listing quantity
        await prisma.listing.update({
          where: { id: listing.id },
          data: { quantity: { decrement: order.quantity } }
        });
        console.log(`✅ Order ${order.id} recorded. Inventory updated.`);
        // (Optional: trigger email notifications to seller/buyer here)
      }
    } catch (err) {
      console.error("Webhook handling error:", err);
      return res.status(500).send("Server error");
    }
  }

  // ... handle other event types if needed ...

  res.status(200).json({ received: true });
}
In this webhook code (registered with Stripe to listen for checkout.session.completed):
We disable Next.js’s body parsing and manually read the raw body (buffer(req)) so we can verify the signature using stripe.webhooks.constructEvent()
pedroalonso.net
. The endpointSecret is the signing secret from our Stripe dashboard (for the webhook endpoint). This ensures the request is genuinely from Stripe.
On a successful payment event, we pull out the session info. We retrieve the listingId from session.metadata. We find the buyer either by an explicit buyerId in metadata or by matching the customer_email to a user (in case we didn’t pass buyerId or if email differs).
Then, we find the listing and create a new Order record in our database with details of the purchase (which buyer, which listing/seller, quantity, total price, etc.), marking it as “paid”. We also reduce the available Listing.quantity by the purchased amount (prisma.listing.update with a decrement).
We log success and could extend this to send notifications: e.g., send an email to the seller with the buyer’s contact and order info, and a confirmation to the buyer (though Stripe already sends a payment receipt to the buyer’s email).
The webhook responds with a 200 to acknowledge receipt. (We include other events handling as needed, but for now we focus on the checkout completion.)
Post-Purchase User Experience: After payment, Stripe will redirect the user to our success_url (e.g., /order-success?session_id=...). We can create a simple page pages/order-success.js that reads the session_id from the query, optionally verifies the order was recorded, and displays a confirmation message (e.g., “Thank you for your purchase! You will receive an email receipt. Please coordinate pickup with the seller.”). This page can also prompt the user to leave a review after pickup.
6. Reviews System
Buyers can rate and review sellers to build trust in the marketplace. We have a Review model linking a buyer, a seller, and an order. To leave a review, the buyer should have completed an order with that seller. Submitting a Review: A simple implementation is to provide a "Leave a Review" form on either the seller’s profile or the order success page. The form would accept a star rating (1-5), a text comment, and an optional photo upload (for produce images, etc.). Upon submission, it calls an API route (e.g., POST /api/reviews) to save the review. For brevity, here’s an outline of the review submission logic (without full form code):
javascript
Copy
Edit
// pages/api/reviews.js
import { getSession } from "next-auth/react";
import { PrismaClient } from "@prisma/client";
const prisma = new PrismaClient();
export default async function handler(req, res) {
  const session = await getSession({ req });
  if (!session) return res.status(401).json({ error: "Unauthorized" });
  const user = await prisma.user.findUnique({ where: { email: session.user.email } });
  if (!user) return res.status(401).json({ error: "User not found" });

  if (req.method === "POST") {
    const { orderId, rating, comment, imageUrl } = req.body;
    // Verify that this order belongs to this user and is completed
    const order = await prisma.order.findUnique({ where: { id: Number(orderId) } });
    if (!order || order.buyerId !== user.id || order.status !== "paid") {
      return res.status(400).json({ error: "Invalid order for review" });
    }
    // Ensure a review doesn't already exist for this order
    const existingReview = await prisma.review.findFirst({ where: { orderId: order.id } });
    if (existingReview) {
      return res.status(400).json({ error: "You have already reviewed this order" });
    }
    // Create the review
    const review = await prisma.review.create({
      data: {
        rating: Number(rating),
        comment,
        imageUrl,
        orderId: order.id,
        sellerId: order.sellerId,
        reviewerId: user.id
      }
    });
    // (Optional: could mark order as reviewed or update any aggregated seller rating)
    res.status(200).json(review);
  } else {
    res.setHeader("Allow", "POST");
    res.status(405).end("Method Not Allowed");
  }
}
This endpoint ensures the user is authenticated and finds their user record. On POST, it checks that the specified order exists, was made by the current user (buyerId matches), and is completed. It also checks that a review for this order hasn’t been made yet (to prevent multiple reviews per purchase). If all good, it creates the review entry in the DB. On success, the new review would immediately be available via our listing detail (or seller profile) page, since those pages load reviews from the database. Displaying Reviews: In the listing detail page code above, we included the seller’s reviewsReceived in the data fetch, and displayed each review with star icons and text. We show the reviewer’s name (or email) and the comment. For the star rating, we simply repeated “★” characters as a visual (Tailwind can also style star icons if we use an icon library). The average rating for a seller could be computed on the fly or stored in the User model for quick access (not shown here). This review system thus allows buyers to provide feedback and helps future buyers trust the platform’s sellers.
7. UI/UX and Design Considerations
The app uses Tailwind CSS for styling, aiming for a clean, modern interface similar to Airbnb. Tailwind’s utility classes provide quick styling without writing custom CSS for every element. Some design choices and features:
Layout: We use a responsive container (max-w-4xl mx-auto or container mx-auto) for centered content. Flexbox and grid utilities create a two-column layout on the listing page, and a grid of cards on the homepage for listings.
Colors & Fonts: A neutral palette is chosen with accents (e.g., green for primary actions like create listing, blue for purchase call-to-action, consistent with a fresh produce theme). We rely on default Tailwind typography which is clean and modern, similar to Airbnb’s simplicity. We also include sufficient whitespace (paddings and margins) to avoid clutter.
Components: We created a reusable Navbar component for top navigation (with sign-in/out). We could similarly componentize the listing card, search bar, etc., but inline code is shown for brevity. Using consistent card styles (borders, rounded corners, shadows) gives an Airbnb-like card-based listing feel.
Mobile-Friendly: All pages use responsive design—e.g., the listings grid is one column on small screens (md:grid-cols-3 means 3 columns on medium and up, 1 column on smaller by default). Buttons and form inputs use full-width or spacing adjustments for small screens. The layout switches to vertical stacking on mobile where needed (as with the listing detail image and info).
Tailwind Configuration: We include a basic Tailwind setup:
tailwind.config.js with content paths (./pages/**/*.{js,jsx}, ./components/**/*.{js,jsx} etc.) so unused classes get purged in production
kombai.com
.
globals.css (imported in _app.js) with Tailwind’s base styles:
css
Copy
Edit
@tailwind base;
@tailwind components;
@tailwind utilities;
This allows us to use classes like text-xl, bg-gray-100, md:flex, etc., directly in JSX.
No heavy custom CSS was written – keeping design changes minimal and relying on Tailwind ensures speed to launch and consistency. The end result is a functional UI that, while simple, is clean and professional. With real product pictures and proper spacing, it can resemble the approachable style of Airbnb’s listings.
Deployment (README)
To run this app in a production or development environment, follow these steps:
Clone the repository: Obtain the code (all files provided above) and place them in a Next.js project structure. Ensure that package.json has the required dependencies: Next.js, React, NextAuth, Prisma, @prisma/client, Stripe, Tailwind CSS, etc. (Using create-next-app and adding these packages is a good start).
Install Dependencies:
bash
Copy
Edit
npm install
This will install Next.js, NextAuth, Prisma, Stripe SDK, and Tailwind CSS (along with PostCSS and autoprefixer as needed).
Set Up Environment Variables: Create a .env.local file in the project root with the following keys (replace values with your credentials):
env
Copy
Edit
DATABASE_URL="postgresql://<username>:<password>@<host>:<port>/<dbname>?schema=public"
GOOGLE_CLIENT_ID="<your-google-oauth-client-id>"
GOOGLE_CLIENT_SECRET="<your-google-oauth-client-secret>"
FACEBOOK_CLIENT_ID="<your-facebook-app-id>"
FACEBOOK_CLIENT_SECRET="<your-facebook-app-secret>"
NEXTAUTH_SECRET="<random-secret-for-session-hash>"  # use `openssl rand -base64 32` to generate
STRIPE_SECRET_KEY="<your-stripe-secret-key>"
NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY="<your-stripe-publishable-key>"
STRIPE_WEBHOOK_SECRET="<your-stripe-webhook-signing-secret>"
NEXT_PUBLIC_BASE_URL="http://localhost:3000"  # or your domain in production
Set up OAuth apps on Google (OAuth 2.0 Client) and Facebook (Facebook Login) to get the above credentials, with authorized redirect URIs to your domain’s /api/auth/callback/* endpoints. In Stripe Dashboard, obtain API keys and add a webhook endpoint for /api/webhook/stripe events (listening for checkout.session.completed). Use the webhook’s signing secret for STRIPE_WEBHOOK_SECRET.
Database Migration: Ensure your PostgreSQL database is running and accessible via the DATABASE_URL. Run Prisma migrations to create tables:
bash
Copy
Edit
npx prisma migrate dev --name init  
npx prisma generate
This will create the tables for User, Account, Session, VerificationToken (if using email, though not in our case), Listing, Order, Review as defined in the schema. The Prisma client will also be generated for database access.
Run the Development Server:
bash
Copy
Edit
npm run dev
This starts Next.js on http://localhost:3000. Open this in your browser. You can now sign in via Google or Facebook, edit your profile, create listings, search, and simulate purchases (you can use Stripe test mode with a test card, e.g., 4242 4242 4242 4242). Ensure Stripe webhooks are being delivered to your dev server (for local testing, you can use the Stripe CLI to forward events to your localhost).
Production Build & Deploy:
For production, build the app and use a Node server or deploy to Vercel:
bash
Copy
Edit
npm run build  
npm start  # runs the built app
On Vercel, just connect the repo – Vercel automatically builds Next.js apps. Set the environment variables in Vercel’s dashboard. You’ll need a live database (consider a service like Supabase, Railway, or Heroku Postgres) and update DATABASE_URL accordingly. Run the migration on the production DB (you can run prisma migrate deploy).
Update OAuth callback URLs in Google/Facebook to your production domain. Update NEXT_PUBLIC_BASE_URL to your production URL for correct redirects.
Post-Deployment Checklist:
Test OAuth logins on the live site.
Test listing creation and searching.
Test the Stripe checkout flow in production mode (you might initially use test mode and then switch to live keys). Ensure webhooks are configured to the correct URL (e.g., https://your-domain.com/api/webhook/stripe) and the signing secret is updated.
Monitor the database (using Prisma Studio or any DB client) to see that records are created/updated as expected (Users, Listings, Orders, Reviews).
Future Enhancements:
Implement image uploads for product and profile images via a service (the code currently expects an imageUrl).
Add seller onboarding for Stripe Connect to automate payouts (collecting banking info from sellers) – currently, the platform holds funds; you might manually pay out or later integrate transfers.
Add messaging or at least share contact number after purchase for coordination.
Implement more robust access control (e.g., only allow editing your own listings, which can be enforced in those API routes).
Polish the UI with better styling or a UI library for modals, toasts, etc., and add pagination for listings if the dataset grows.